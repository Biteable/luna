{
  "version": 3,
  "sources": ["../wip/transition.ts", "../dom/class.ts", "../dom/query.ts", "transition.ts"],
  "sourcesContent": ["/*\n\nWhy this when we have Element.animate in all browsers?\n------------------------------------------------------\n\nThere's a crucial difference between transitions and animations.\nThe latter run until completion, and the former don't. If you want to undo/change/reverse an animation while it's still running, then you want a transition. For instance, clicking on a navigation hamburger icon should I really really have to wait for the animation to finish or should I be able to quickly tap again and have the nav (from its half-open state) return close.\n\n- [ ] I think. @todo\n- [ ] Can we call Element.animate before an element has finished animating and get smooth sequencing from the current animation state forwards into the next animation?\n\n\nFurther reading on Element.animate\n\nYouTube: Web animation gotchas - HTTP 203\nhttps://www.youtube.com/watch?v=9-6CKCz58A8&ab_channel=GoogleChromeDevelopers\nhttps://gist.github.com/jakearchibald/0b50c4918eaf9a67bfcfa55e7e61cd56\n\n*/\n\ninterface Args {\n  setup?: () => void, // add is-transitioning class\n  trigger?: () => void, // change state classes/attributes\n  end?: () => void, // remove is-transitiong class\n  // watch?: [any],\n}\n\n\nlet elsInTransition: HTMLElement[] = []\n\n\nexport function transition (el: HTMLElement, args: Args) {\n  console.log(\"-----------------------------\")\n\n  const nextFrame = (cb: () => void) => requestAnimationFrame(() => requestAnimationFrame(cb))\n  const transitionend = \"transitionend\"\n  const transitionrun = \"transitionrun\"\n\n  /*\n    An element won't fire \"transitionrun\" and \"transitionend\" events if it's not going to transition.\n    This lack of events will happen when:\n    - [ ] When the state doesn't change, ie you're transitioning to opacity: 1 and the opacity is already 1\n    - [ ] A duration of 0? What about when there's a delay?\n  */\n  let willTransition: boolean\n\n  const isTransitioning = elsInTransition.indexOf(el) !== -1\n  if (!isTransitioning) elsInTransition.push(el)\n  if (isTransitioning) {\n    console.log(\"isTransitioning, overriding willTransition because already rtransitioning\")\n  }\n\n  const removeFromElsInTransition = () => {\n    const ix = elsInTransition.indexOf(el)\n    if (ix !== -1) elsInTransition.splice(ix, 1)\n  }\n\n  const onTransitionRun = (e: Event) => {\n    console.log(\"transitionrun\")\n    willTransition = true\n    el.removeEventListener(transitionrun, onTransitionRun)\n  }\n\n  const onEnd = () => {\n    if (args.end) args.end()\n    el.removeEventListener(transitionend, onTransitionEnd)\n    removeFromElsInTransition()\n  }\n\n  const onTransitionEnd = (e: Event) => {\n    if (e.target === el) {\n      console.log(\"onTransitionEnd\")\n      onEnd()\n    }\n  }\n\n  // 1. Setup: apply initial styles\n  // This is where you apply your \"is-transitioning\" class with transition timing, duration, and the css properties you want to, or take any measurements about the initial state of the element\n  // It's here we add our listener for the transitionend event.\n  // Lastly we read a property on the element that triggers reflow so attribute/class changes in the trigger step don't occur in the same paint frame as the setup changes. Could use 2x rAFs probably\n  if (args.setup) args.setup()\n  el.addEventListener(transitionend, onTransitionEnd)\n  el.addEventListener(transitionrun, onTransitionRun)\n\n  // void el.offsetWidth // @todo needed?\n\n  // 2. Trigger\n  // This is where you trigger the transition. For example, setting opacity 0 on an element you're fading out.\n  if (args.trigger) args.trigger()\n\n  // void el.offsetWidth // @todo needed?\n\n  // 3. End\n  // The transitionend event should handle this base on the css transition timing/duration you use, but when no transition is found the even won't fire. So we call it manually.\n  nextFrame(() => {\n    console.log(\"willTransition\", willTransition)\n    if (!willTransition && !isTransitioning) {\n      console.log(\"exit early because !willTransition\")\n      onEnd()\n    }\n  })\n}\n\n\n// let listeners: [HTMLElement, () => any][] = []\n\n\n// Prologue\n// Remove any existing event listeners\n// listeners.filter(([elem]) => elem === el)\n//   .reverse() //\n//   .forEach(listener => {\n//     const [elem, cb] = listener\n//     listeners.splice(listeners.indexOf(listener), 1)\n//     elem.removeEventListener(transitionend, cb)\n//   })\n\n\n// function getDuration (el: HTMLElement): number {\n//   const computedStyles = getComputedStyle(el)\n//   const duration = computedStyles[\"transitionDuration\"]\n//   const delay = computedStyles[\"transitionDelay\"]\n\n//   return ((parseFloat(duration) + parseFloat(delay)) * 1000)\n// }\n", "/*\n  Aside from filling some missing functionality in IE, the only real difference is that most methods return the element so it can be chained\n\n  IE's Element.classList:\n  - doesn't support the `force` argument on `toggle`\n  - doesn't support multiple arguments for `add` and `remove`\n  - doesn't support `replace`\n\n  Note that there's no IE support for Element.classList in IE9 and older.\n\n  https://developer.mozilla.org/en-US/docs/Web/API/Element/classList\n*/\n\nexport const addClass = (el: HTMLElement, ...classNames: string[]) => {\n  el.classList.add(...classNames)\n  return el\n}\n\nexport const removeClass = (el: HTMLElement, ...classNames: string[]) => {\n  el.classList.remove(...classNames)\n  return el\n}\n\nexport const toggleClass = (el: HTMLElement, className: string, force?: boolean) => {\n  el.classList.toggle(className, force)\n  return el\n\n  // Internet Explorer doesn't support the force argument\n  // If you need IE support, replace with the below\n  /*\n    if (force === undefined) {\n      el.classList.toggle(className)\n    } else {\n      force\n        ? el.classList.remove(className)\n        : el.classList.add(className)\n    }\n    return el\n  */\n}\n\nexport const containsClass = (el: HTMLElement, className: string) => {\n  return el.classList.contains(className)\n}\n\n// Curried methods\n// Awesome in pipe\n// const addActiveClass = addsClass(\"active\")\n\nexport const addsClass = (...classNames: string[]) => {\n  return (el: HTMLElement) => addClass(el, ...classNames)\n}\n\nexport const removesClass = (...classNames: string[]) => {\n  return (el: HTMLElement) => removeClass(el, ...classNames)\n}\n\nexport const togglesClass = (className: string, force?: boolean) => {\n  return (el: HTMLElement) => toggleClass(el, className, force)\n}\n", "export const find = (scope: HTMLElement | Document, selector: string) => scope.querySelector(selector) as HTMLElement\n\nexport const findAll = (scope: HTMLElement | Document, selector: string) => [].slice.call(scope.querySelectorAll(selector)) as HTMLElement[]\n\nexport const query = (selector: string) => find(document, selector)\n\nexport const queryAll = (selector: string) => findAll(document, selector)\n", "import { transition } from \"../wip/transition\"\nimport { query } from \"../dom\"\nimport { addClass, removeClass } from \"../dom/class\"\n// import {  }\n\n\nconst nav = query(\"nav\")\nconst showBtn = query(\"[data-action=show]\")\nconst hideBtn = query(\"[data-action=hide]\")\n\ndocument.addEventListener(\"keyup\", (e) => {\n  if (e.key === \"s\") show()\n  if (e.key === \"j\") show()\n  if (e.key === \"h\") hide()\n})\n\nshowBtn.addEventListener(\"click\", show)\nhideBtn.addEventListener(\"click\", hide)\n\n\nfunction show () {\n  transition(nav, {\n    setup: () => {\n      console.log(\"show::setup\")\n    },\n    trigger: () => {\n      console.log(\"show::trigger\")\n      addClass(nav, \"is-transitioning\", \"is-visible\")\n    },\n    end: () => {\n      console.log(\"show::end\")\n      removeClass(nav, \"is-transitioning\")\n    },\n  })\n}\n\nfunction hide () {\n  transition(nav, {\n    setup: () => { console.log(\"hide::start\") },\n    trigger: () => {\n      console.log(\"hide::trigger\")\n      addClass(nav, \"is-transitioning\")\n      removeClass(nav, \"is-visible\")\n    },\n    end: () => {\n      console.log(\"hide::end\")\n      removeClass(nav, \"is-transitioning\")\n    },\n  })\n}\n"],
  "mappings": "MA4BA,GAAI,GAAiC,GAG9B,WAAqB,EAAiB,EAAY,CACvD,QAAQ,IAAI,iCAEZ,GAAM,GAAY,AAAC,GAAmB,sBAAsB,IAAM,sBAAsB,IAClF,EAAgB,gBAChB,EAAgB,gBAQlB,EAEE,EAAkB,EAAgB,QAAQ,KAAQ,GACxD,AAAK,GAAiB,EAAgB,KAAK,GACvC,GACF,QAAQ,IAAI,6EAGd,GAAM,GAA4B,IAAM,CACtC,GAAM,GAAK,EAAgB,QAAQ,GACnC,AAAI,IAAO,IAAI,EAAgB,OAAO,EAAI,IAGtC,EAAkB,AAAC,GAAa,CACpC,QAAQ,IAAI,iBACZ,EAAiB,GACjB,EAAG,oBAAoB,EAAe,IAGlC,EAAQ,IAAM,CAClB,AAAI,EAAK,KAAK,EAAK,MACnB,EAAG,oBAAoB,EAAe,GACtC,KAGI,EAAkB,AAAC,GAAa,CACpC,AAAI,EAAE,SAAW,GACf,SAAQ,IAAI,mBACZ,MAQJ,AAAI,EAAK,OAAO,EAAK,QACrB,EAAG,iBAAiB,EAAe,GACnC,EAAG,iBAAiB,EAAe,GAM/B,EAAK,SAAS,EAAK,UAMvB,EAAU,IAAM,CACd,QAAQ,IAAI,iBAAkB,GAC1B,CAAC,GAAkB,CAAC,GACtB,SAAQ,IAAI,sCACZ,OCrFC,GAAM,GAAW,CAAC,KAAoB,IAC3C,GAAG,UAAU,IAAI,GAAG,GACb,GAGI,EAAc,CAAC,KAAoB,IAC9C,GAAG,UAAU,OAAO,GAAG,GAChB,GCpBF,GAAM,GAAO,CAAC,EAA+B,IAAqB,EAAM,cAAc,GAItF,GAAM,GAAQ,AAAC,GAAqB,EAAK,SAAU,GCE1D,GAAM,GAAM,EAAM,OACZ,EAAU,EAAM,sBAChB,EAAU,EAAM,sBAEtB,SAAS,iBAAiB,QAAS,AAAC,GAAM,CACxC,AAAI,EAAE,MAAQ,KAAK,IACf,EAAE,MAAQ,KAAK,IACf,EAAE,MAAQ,KAAK,MAGrB,EAAQ,iBAAiB,QAAS,GAClC,EAAQ,iBAAiB,QAAS,GAGlC,YAAiB,CACf,EAAW,EAAK,CACd,MAAO,IAAM,CACX,QAAQ,IAAI,gBAEd,QAAS,IAAM,CACb,QAAQ,IAAI,iBACZ,EAAS,EAAK,mBAAoB,eAEpC,IAAK,IAAM,CACT,QAAQ,IAAI,aACZ,EAAY,EAAK,uBAKvB,YAAiB,CACf,EAAW,EAAK,CACd,MAAO,IAAM,CAAE,QAAQ,IAAI,gBAC3B,QAAS,IAAM,CACb,QAAQ,IAAI,iBACZ,EAAS,EAAK,oBACd,EAAY,EAAK,eAEnB,IAAK,IAAM,CACT,QAAQ,IAAI,aACZ,EAAY,EAAK",
  "names": []
}
