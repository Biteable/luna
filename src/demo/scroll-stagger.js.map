{
  "version": 3,
  "sources": ["../dom/offset.ts", "../dom/query.ts", "../util/clamp.ts", "../util/debounce.ts", "../util/stagger.ts", "../scrollListener/index.ts", "scroll-stagger.ts"],
  "sourcesContent": ["/*\n\noffset(el: HTMLElement)\n=======================\n\nReturns element offsets and dimensions relative to the html element, excluding any transforms (eg `translateX`, `scaleY` etc) have been applied.\n\nThis is designed with the same properties as `Element.getBoundingClientRect()` but the use case is subtly different.\n\nImagine an element `el` that's `100px` wide and has a css transform `scale(0.5)`. `Element.offsetWidth` returns the value `100` while `Element.getBoundingClientRect().width` returns `50`.\n\nSee also `Element.scrollWidth`\n\n> If you need to know the actual size of the content, regardless of how much of it is currently visible, you need to use the Element.scrollWidth and Element.scrollHeight properties. These return the width and height of the entire content of an element, even if only part of it is presently visible due to the use of scroll bars.\n> -- https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model/Determining_the_dimensions_of_elements\n\n\n*/\n\nexport interface OffsetData {\n  top: number\n  bottom: number\n  left: number\n  right: number\n  width: number\n  height: number\n}\n\nexport const offset = (el: HTMLElement): OffsetData => {\n  let top = 0\n  let left = 0\n  const width = el.offsetWidth\n  const height = el.offsetHeight\n\n  while (el) {\n    top += el.offsetTop\n    left += el.offsetLeft\n    el = el.offsetParent as HTMLElement\n  }\n\n  /*\n    clientWidth vs offsetWidth\n    tl; dr clientWidth is the inner containing area excluding the scrollbar, probably what we want for the root dimensions\n\n    https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth\n    https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetWidth\n  */\n  const bottom = document.documentElement.clientHeight - height\n  const right = document.documentElement.clientWidth - width\n\n  return { top, bottom, left, right, width, height }\n}\n", "export const find = (scope: HTMLElement | Document, selector: string) => scope.querySelector(selector) as HTMLElement\n\nexport const findAll = (scope: HTMLElement | Document, selector: string) => [].slice.call(scope.querySelectorAll(selector)) as HTMLElement[]\n\nexport const query = (selector: string) => find(document, selector)\n\nexport const queryAll = (selector: string) => findAll(document, selector)\n", "const clamp = (min: number, value: number, max: number) => {\n  if (min !== null && min !== undefined && value < min) return min\n  if (max !== null && max !== undefined && value > max) return max\n  return value\n}\n\nexport { clamp }", "export const debounce = (func: any, wait: number, immediate: boolean = false) => {\n  let timeout: number\n  return function () {\n    var context = this, args = arguments\n    window.clearTimeout(timeout)\n    timeout = window.setTimeout(function () {\n      timeout = null\n      if (!immediate) func.apply(context, args)\n    }, wait)\n    if (immediate && !timeout) func.apply(context, args)\n  }\n}\n", "/*\nStagger\n\nHelps you sequence callbaks together\n\nSometimes it's hard to orchestrate mutiple things together. Let's say you're trying to detect when mutiple elements enter the screen at the same time (could be IO, could be on page load, whatever) and animate them in one after the other in a sequence. This staggering can be tricky to manage since you typically need to defer that behaviour up onto a parent element that understands the positions of all its children.\n\nThis is a different approach. You can just call `stagger` with a namespace (to ensure you scope staggering to like elements -- for example one group for animating in your main navigation items, and another group for animating your boor previews on screen), the element you want effect, and a callback which recieves the index (0 based order) of the element in its group of any other elements in the same stagger namespace that will do their thing in the same animation frame.\n*/\n\n\ntype Callback = (staggerIndex: number, staggerTotal: number) => any\n\n\nlet groups: {\n  [key: string]: {\n    el: HTMLElement\n    cb: Callback\n  }[]\n} = {}\n\n\nexport function stagger (namespace: string, el: HTMLElement, cb: Callback) {\n  // Add el and callback to a group using namespace as key\n  if (!groups[namespace]) groups[namespace] = []\n  groups[namespace].push({ el, cb })\n\n  // This is the mechanism for determining different callbacks that should run at the same time. Previously we used requestAnimationFrame but this is preferred.\n\n  // > Using 0 as the value for setTimeout() schedules the execution of the specified callback function as soon as possible but only after the main code thread has been run.\n  // ref: https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Timeouts_and_intervals#immediate_timeouts\n  setTimeout(processGroups, 0)\n}\n\n\nfunction processGroups () {\n  // Iterate each group separately\n  for (const namespace in groups) {\n    const length = groups[namespace].length\n    groups[namespace]\n      .sort(sortByDocumentPosition) // Order elements by DOM position\n      .forEach((x, ix) => {\n        x.cb(ix, length) // Call callback with index and group length as arguments\n      })\n  }\n\n  // Reset groups\n  groups = {}\n}\n\n\nfunction sortByDocumentPosition (a: { el: HTMLElement }, b: { el: HTMLElement }) {\n  if (a.el === b.el) return 0\n  if (a.el.compareDocumentPosition(b.el) & 2) return 1 // b comes before a\n  return -1\n}\n", "import { offset as getOffset, OffsetData } from \"../dom\"\nimport { clamp, debounce } from \"../util\"\n\n\ninterface RootData {\n  scrollX?: number\n  scrollY?: number\n  scrollHeight?: number\n  direction?: Direction\n  width?: number\n  height?: number\n}\n\ninterface Entry {\n  target: HTMLElement\n  // Offsets are relative to the document, not the viewport.\n  top: number\n  bottom: number\n  left: number\n  right: number\n  width: number\n  height: number\n}\n\ninterface TrackedEntryData {\n  entry: Entry\n  cb: ScrollCallback\n}\n\ninterface ScrollData {\n  root: RootData\n  entry: Entry\n}\n\nexport type ScrollCallback = (data: ScrollData) => any\ntype Direction = \"DOWN\" | \"UP\"\nexport const DOWN: Direction = \"DOWN\"\nexport const UP: Direction = \"UP\"\n\n\nlet initiated = false\nlet entries: TrackedEntryData[] = []\nlet lastScrollY: number\nlet root: RootData = {}\nlet domObserver: MutationObserver\n\n\nexport function update () {\n  // console.log(\"::update\")\n  measureRootData()\n  measureOffsets()\n  onScroll()\n}\n\n\nconst debouncedOnResize = debounce(update, 250)\n\n\nfunction measureOffsets () {\n  for (let i = 0; i < entries.length; i++) {\n    Object.assign(entries[i].entry, getOffset(entries[i].entry.target))\n  }\n}\n\n\nfunction measureRootData () {\n  // console.log(\"::measureRootData\")\n  const w = window\n  const html = document.documentElement\n\n  root.scrollX = w.scrollX\n  root.scrollY = w.scrollY\n  root.scrollHeight = html.scrollHeight // @note maybe cache\n  root.direction = w.scrollY >= lastScrollY ? DOWN : UP\n  root.width = html.clientWidth // * clientWidth vs offsetWidth\n  root.height = html.clientHeight // @note maybe cache\n}\n\n\nfunction onScroll () {\n  const length = entries.length\n  if (!length) return\n  // console.log(\"::onScroll\")\n\n  // Update root data\n  root.scrollX = window.scrollX\n  root.scrollY = window.scrollY\n  root.direction = window.scrollY >= lastScrollY ? DOWN : UP\n\n  // Iterate in reverse order. Elements can be removed (and possibly added) from callbacks originating within this loop.\n  for (let i = length - 1; i >= 0; i--) {\n    const { entry, cb } = entries[i]\n    cb({ entry, root })\n  }\n}\n\n\nexport function addScrollListener (target: HTMLElement, cb: ScrollCallback) {\n  // Don't subscribe the same callback + element multiple times\n  if (entries.some((obj) => obj.entry.target === target && obj.cb === cb)) {\n    console.error(\"addScrollListener: target already subscribed with callback\")\n    return\n  }\n\n  const entry: Entry = Object.assign({ target }, getOffset(target))\n  entries.push({ entry, cb })\n\n  if (!initiated) {\n    initiated = true\n    update()\n    addEventListeners()\n  }\n\n  cb({ entry, root }) // Immediately apply callbacks for added target\n}\n\n\n// If a callback is passed, ubsubcribe just that callback, otherwise ubsubscribe the target element completely\nexport function removeScrollListener (target: HTMLElement, cb?: ScrollCallback) {\n  if (cb) {\n    entries = entries.filter((obj) => !(obj.entry.target === target && obj.cb === cb))\n  } else {\n    entries = entries.filter((obj) => !(obj.entry.target === target))\n  }\n}\n\n\nexport function removeAll () {\n  initiated = false\n  entries = []\n  removeEventListeners()\n}\n\n\nfunction addEventListeners () {\n  window.addEventListener(\"scroll\", onScroll, { passive: true })\n  window.addEventListener(\"resize\", update, { passive: true })\n  domObserver = new MutationObserver(debouncedOnResize)\n  domObserver.observe(document.documentElement, { attributes: false, childList: true, subtree: true })\n}\n\n\nfunction removeEventListeners () {\n  window.removeEventListener(\"scroll\", onScroll)\n  window.removeEventListener(\"resize\", update)\n  domObserver.disconnect()\n}\n\n// Right now rootMargin sets both vertical directions (top and bottom) evenly. Later we might want to add top and bottom values separately.\n// Just like with IntersectionObserver, rootMargin is a negative value if you want the root ... @todo check this.\nexport const isIntersecting = (data: ScrollData, rootMargin: number = 0): boolean => {\n  const { entry, root } = data\n  const rootTop = root.scrollY + rootMargin\n  const rootBottom = root.scrollY + root.height - rootMargin\n\n  return entry.top < rootBottom && entry.top + entry.height > rootTop\n}\n\n\n// Just like with IO.entry.isIntersecting, if the target element is taller than the root you will never get a ratio of 1.\nexport const intersectionRatio = (data: ScrollData, rootMargin: number = 0): number => {\n  if (!isIntersecting(data, rootMargin)) return 0\n\n  const { entry, root } = data\n\n  if (entry.height === 0) return 0\n\n  const rootTop = root.scrollY + rootMargin\n  const rootBottom = root.scrollY + root.height - rootMargin\n  const overlap = Math.min(rootBottom - entry.top, entry.top + entry.height - rootTop, entry.height, root.height)\n\n  return clamp(0, overlap / entry.height, 1)\n}\n\n\n// Like intersectionRatio but normalised so that you always get a linear 0 to 1 value; eg 0 when target element is about to enter the viewport to 1 when the vertical center of the target aligns with the vertical center of the root.\nexport const intersectionValue = (data: ScrollData, rootMargin: number = 0): number => {\n  if (!isIntersecting(data, rootMargin)) return 0\n\n  const { entry, root } = data\n  const rootTopY = root.scrollY - (entry.height / 2) + rootMargin\n  const rootBottomY = root.scrollY + (entry.height / 2) + root.height - rootMargin\n  const rootHeight = rootBottomY - rootTopY\n  const rootMiddleY = rootTopY + rootHeight / 2\n  const entryMiddleY = entry.top + (entry.height / 2)\n\n  if (entryMiddleY === rootMiddleY) return 1\n  if (entryMiddleY < rootMiddleY) return 1 - (rootMiddleY - entryMiddleY) / (rootHeight / 2)\n  if (entryMiddleY > rootMiddleY) return 1 + (rootMiddleY - entryMiddleY) / (rootHeight / 2)\n}\n", "import { query, queryAll } from \"../dom\"\nimport { addScrollListener, removeScrollListener, intersectionRatio, ScrollCallback, isIntersecting } from \"../scrollListener\"\nimport { stagger } from \"../util/stagger\"\n\n\n// const r = query(\".root\")\n// addScrollListener(r, ({ root }) => {\n//   requestAnimationFrame(() => {\n//     r.style.height = root.height + \"px\"\n//     r.style.top = root.scrollY + \"px\"\n//   })\n// })\n\nqueryAll(\".card\").forEach((el, ix) => {\n  if (ix == 10) el.style.outline = \"10px solid pink\"\n\n  let done = 0\n  const onscroll: ScrollCallback = (data) => {\n    if (intersectionRatio(data) > 0.2) {\n      el.setAttribute(\"data-intersected\", \"\")\n\n      // Remove immediately so we do this only once on a matching intersection\n      removeScrollListener(el, onscroll)\n      if (done) console.log(\"!fired too many times\", el, done)\n      done++\n\n\n      // Create a namespace that so that only elements with this same namespace that also have a stagger callback scheduled for the same paint frame get treated as stagger siblings\n      const namespace = \"visible-card\"\n      // const namespace = \"card\" + data.entry.top\n\n      // Call stagger. In this case we are delaying the adding of a classname so that elements animate in a sequence\n      stagger(namespace, el, (ix) => {\n        // ix is the (0 based) index of this element in it's siblings\n        setTimeout(() => {\n          requestAnimationFrame(() => {\n            el.classList.add(\"is-visible\")\n          })\n        }, ix * 100)\n      })\n    }\n  }\n\n  addScrollListener(el, onscroll)\n})\n"],
  "mappings": "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",
  "names": []
}
