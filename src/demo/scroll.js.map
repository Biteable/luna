{
  "version": 3,
  "sources": ["../dom/offset.ts", "../dom/query.ts", "../util/clamp.ts", "../util/debounce.ts", "../scrollListener/index.ts", "../wip/color.ts", "../easings/index.ts", "scroll.ts"],
  "sourcesContent": ["/*\n\noffset(el: HTMLElement)\n=======================\n\nReturns element offsets and dimensions relative to the html element, excluding any transforms (eg `translateX`, `scaleY` etc) have been applied.\n\nThis is designed with the same properties as `Element.getBoundingClientRect()` but the use case is subtly different.\n\nImagine an element `el` that's `100px` wide and has a css transform `scale(0.5)`. `Element.offsetWidth` returns the value `100` while `Element.getBoundingClientRect().width` returns `50`.\n\nSee also `Element.scrollWidth`\n\n> If you need to know the actual size of the content, regardless of how much of it is currently visible, you need to use the Element.scrollWidth and Element.scrollHeight properties. These return the width and height of the entire content of an element, even if only part of it is presently visible due to the use of scroll bars.\n> -- https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model/Determining_the_dimensions_of_elements\n\n\n*/\n\nexport interface OffsetData {\n  top: number\n  bottom: number\n  left: number\n  right: number\n  width: number\n  height: number\n}\n\nexport const offset = (el: HTMLElement): OffsetData => {\n  let top = 0\n  let left = 0\n  const width = el.offsetWidth\n  const height = el.offsetHeight\n\n  while (el) {\n    top += el.offsetTop\n    left += el.offsetLeft\n    el = el.offsetParent as HTMLElement\n  }\n\n  /*\n    clientWidth vs offsetWidth\n    tl; dr clientWidth is the inner containing area excluding the scrollbar, probably what we want for the root dimensions\n\n    https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth\n    https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetWidth\n  */\n  const bottom = document.documentElement.clientHeight - height\n  const right = document.documentElement.clientWidth - width\n\n  return { top, bottom, left, right, width, height }\n}\n", "export const find = (scope: HTMLElement | Document, selector: string) => scope.querySelector(selector) as HTMLElement\n\nexport const findAll = (scope: HTMLElement | Document, selector: string) => [].slice.call(scope.querySelectorAll(selector)) as HTMLElement[]\n\nexport const query = (selector: string) => find(document, selector)\n\nexport const queryAll = (selector: string) => findAll(document, selector)\n", "const clamp = (min: number, value: number, max: number) => {\n  if (min !== null && min !== undefined && value < min) return min\n  if (max !== null && max !== undefined && value > max) return max\n  return value\n}\n\nexport { clamp }", "export const debounce = (func: any, wait: number, immediate: boolean = false) => {\n  let timeout: number\n  return function () {\n    var context = this, args = arguments\n    window.clearTimeout(timeout)\n    timeout = window.setTimeout(function () {\n      timeout = null\n      if (!immediate) func.apply(context, args)\n    }, wait)\n    if (immediate && !timeout) func.apply(context, args)\n  }\n}\n", "import { offset as getOffset, OffsetData } from \"../dom\"\nimport { clamp, debounce } from \"../util\"\n\n\ninterface RootData {\n  scrollX?: number\n  scrollY?: number\n  scrollHeight?: number\n  direction?: Direction\n  width?: number\n  height?: number\n}\n\ninterface Entry {\n  target: HTMLElement\n  // Offsets are relative to the document, not the viewport.\n  top: number\n  bottom: number\n  left: number\n  right: number\n  width: number\n  height: number\n}\n\ninterface TrackedEntryData {\n  entry: Entry\n  cb: ScrollCallback\n}\n\ninterface ScrollData {\n  root: RootData\n  entry: Entry\n}\n\nexport type ScrollCallback = (data: ScrollData) => any\ntype Direction = \"DOWN\" | \"UP\"\nexport const DOWN: Direction = \"DOWN\"\nexport const UP: Direction = \"UP\"\n\n\nlet initiated = false\nlet entries: TrackedEntryData[] = []\nlet lastScrollY: number\nlet root: RootData = {}\nlet domObserver: MutationObserver\n\n\nexport function update () {\n  // console.log(\"::update\")\n  measureRootData()\n  measureOffsets()\n  onScroll()\n}\n\n\nconst debouncedOnResize = debounce(update, 250)\n\n\nfunction measureOffsets () {\n  for (let i = 0; i < entries.length; i++) {\n    Object.assign(entries[i].entry, getOffset(entries[i].entry.target))\n  }\n}\n\n\nfunction measureRootData () {\n  // console.log(\"::measureRootData\")\n  const w = window\n  const html = document.documentElement\n\n  root.scrollX = w.scrollX\n  root.scrollY = w.scrollY\n  root.scrollHeight = html.scrollHeight // @note maybe cache\n  root.direction = w.scrollY >= lastScrollY ? DOWN : UP\n  root.width = html.clientWidth // * clientWidth vs offsetWidth\n  root.height = html.clientHeight // @note maybe cache\n}\n\n\nfunction onScroll () {\n  const length = entries.length\n  if (!length) return\n  // console.log(\"::onScroll\")\n\n  // Update root data\n  root.scrollX = window.scrollX\n  root.scrollY = window.scrollY\n  root.direction = window.scrollY >= lastScrollY ? DOWN : UP\n\n  // Iterate in reverse order. Elements can be removed (and possibly added) from callbacks originating within this loop.\n  for (let i = length - 1; i >= 0; i--) {\n    const { entry, cb } = entries[i]\n    cb({ entry, root })\n  }\n}\n\n\nexport function addScrollListener (target: HTMLElement, cb: ScrollCallback) {\n  // Don't subscribe the same callback + element multiple times\n  if (entries.some((obj) => obj.entry.target === target && obj.cb === cb)) {\n    console.error(\"addScrollListener: target already subscribed with callback\")\n    return\n  }\n\n  const entry: Entry = Object.assign({ target }, getOffset(target))\n  entries.push({ entry, cb })\n\n  if (!initiated) {\n    initiated = true\n    update()\n    addEventListeners()\n  }\n\n  cb({ entry, root }) // Immediately apply callbacks for added target\n}\n\n\n// If a callback is passed, ubsubcribe just that callback, otherwise ubsubscribe the target element completely\nexport function removeScrollListener (target: HTMLElement, cb?: ScrollCallback) {\n  if (cb) {\n    entries = entries.filter((obj) => !(obj.entry.target === target && obj.cb === cb))\n  } else {\n    entries = entries.filter((obj) => !(obj.entry.target === target))\n  }\n}\n\n\nexport function removeAll () {\n  initiated = false\n  entries = []\n  removeEventListeners()\n}\n\n\nfunction addEventListeners () {\n  window.addEventListener(\"scroll\", onScroll, { passive: true })\n  window.addEventListener(\"resize\", update, { passive: true })\n  domObserver = new MutationObserver(debouncedOnResize)\n  domObserver.observe(document.documentElement, { attributes: false, childList: true, subtree: true })\n}\n\n\nfunction removeEventListeners () {\n  window.removeEventListener(\"scroll\", onScroll)\n  window.removeEventListener(\"resize\", update)\n  domObserver.disconnect()\n}\n\n// Right now rootMargin sets both vertical directions (top and bottom) evenly. Later we might want to add top and bottom values separately.\n// Just like with IntersectionObserver, rootMargin is a negative value if you want the root ... @todo check this.\nexport const isIntersecting = (data: ScrollData, rootMargin: number = 0): boolean => {\n  const { entry, root } = data\n  const rootTop = root.scrollY + rootMargin\n  const rootBottom = root.scrollY + root.height - rootMargin\n\n  return entry.top < rootBottom && entry.top + entry.height > rootTop\n}\n\n\n// Just like with IO.entry.isIntersecting, if the target element is taller than the root you will never get a ratio of 1.\nexport const intersectionRatio = (data: ScrollData, rootMargin: number = 0): number => {\n  if (!isIntersecting(data, rootMargin)) return 0\n\n  const { entry, root } = data\n\n  if (entry.height === 0) return 0\n\n  const rootTop = root.scrollY + rootMargin\n  const rootBottom = root.scrollY + root.height - rootMargin\n  const overlap = Math.min(rootBottom - entry.top, entry.top + entry.height - rootTop, entry.height, root.height)\n\n  return clamp(0, overlap / entry.height, 1)\n}\n\n\n// Like intersectionRatio but normalised so that you always get a linear 0 to 1 value; eg 0 when target element is about to enter the viewport to 1 when the vertical center of the target aligns with the vertical center of the root.\nexport const intersectionValue = (data: ScrollData, rootMargin: number = 0): number => {\n  if (!isIntersecting(data, rootMargin)) return 0\n\n  const { entry, root } = data\n  const rootTopY = root.scrollY - (entry.height / 2) + rootMargin\n  const rootBottomY = root.scrollY + (entry.height / 2) + root.height - rootMargin\n  const rootHeight = rootBottomY - rootTopY\n  const rootMiddleY = rootTopY + rootHeight / 2\n  const entryMiddleY = entry.top + (entry.height / 2)\n\n  if (entryMiddleY === rootMiddleY) return 1\n  if (entryMiddleY < rootMiddleY) return 1 - (rootMiddleY - entryMiddleY) / (rootHeight / 2)\n  if (entryMiddleY > rootMiddleY) return 1 + (rootMiddleY - entryMiddleY) / (rootHeight / 2)\n}\n", "// import { clamp } from \"../util/clamp\"\n\n\n// Converts a #ffffff hex string into an [r,g,b] array\n// const hexToRGB = (hex: string) => {\n//   var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n//   return result ? [\n//     parseInt(result[1], 16),\n//     parseInt(result[2], 16),\n//     parseInt(result[3], 16)\n//   ] : null\n// }\n\n\nexport type RGBA = [r: number, g: number, b: number, a?: number]\n\nexport const interpolateRGB = (\n  color1: RGBA,\n  color2: RGBA,\n  factor: number\n): RGBA => {\n  // factor = clamp(0, factor, 1)\n  factor = factor > 1 ? 1 : factor < 0 ? 0 : factor // clamp\n\n  const [ r1, g1, b1, a1 = 1 ] = color1\n  const [ r2, g2, b2, a2 = 1 ] = color2\n\n  const r = Math.round(r1 + factor * (r2 - r1))\n  const g = Math.round(g1 + factor * (g2 - g1))\n  const b = Math.round(b1 + factor * (b2 - b1))\n  const a = a1 + factor * (a2 - a1) // Alpha 0-1\n\n  return [r, g, b, a];\n}\n", "// See also https://easings.net/\n\n/*\n * From https://gist.github.com/gre/1650294\n *\n * Easing Functions - inspired from http://gizma.com/easing/\n * only considering the t value for the range [0, 1] => [0, 1]\n */\n\n// no easing, no acceleration\nexport function linear (t: number) {\n  return t;\n}\n// accelerating from zero velocity\nexport function easeInQuad (t: number) {\n  return t * t;\n}\n// decelerating to zero velocity\nexport function easeOutQuad (t: number) {\n  return t * (2 - t);\n}\n// acceleration until halfway, then deceleration\nexport function easeInOutQuad (t: number) {\n  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n}\n// accelerating from zero velocity\nexport function easeInCubic (t: number) {\n  return t * t * t;\n}\n// decelerating to zero velocity\nexport function easeOutCubic (t: number) {\n  return --t * t * t + 1;\n}\n// acceleration until halfway, then deceleration\nexport function easeInOutCubic (t: number) {\n  return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n}\n// accelerating from zero velocity\nexport function easeInQuart (t: number) {\n  return t * t * t * t;\n}\n// decelerating to zero velocity\nexport function easeOutQuart (t: number) {\n  return 1 - --t * t * t * t;\n}\n// acceleration until halfway, then deceleration\nexport function easeInOutQuart (t: number) {\n  return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n}\n// accelerating from zero velocity\nexport function easeInQuint (t: number) {\n  return t * t * t * t * t;\n}\n// decelerating to zero velocity\nexport function easeOutQuint (t: number) {\n  return 1 + --t * t * t * t * t;\n}\n// acceleration until halfway, then deceleration\nexport function easeInOutQuint (t: number) {\n  return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n}\n", "import { query, queryAll } from \"../dom\"\nimport { addScrollListener, intersectionValue, ScrollCallback, intersectionRatio } from \"../scrollListener\"\nimport { interpolateRGB, RGBA } from \"../wip/color\"\nimport { easeInOutQuad, easeOutQuad, easeInQuad } from \"../easings\"\nimport { clamp } from \"../util/clamp\"\nimport { stagger } from \"../util/stagger\"\n\n\nconst reddish = [255, 72, 0] as RGBA\nconst rebeccapurple = [102, 51, 153] as RGBA\nconst greenyellow = [173, 255, 47] as RGBA\n\n\nconst paragraphs = queryAll(\"p\")\nparagraphs.forEach((el, ix, arr) => {\n  let prevValue: number\n\n  if (ix === 40) {\n    el.style.outline = \"5px solid black\"\n  }\n\n  const onScroll: ScrollCallback = (data) => {\n    const { root } = data\n    const value = intersectionValue(data, 0)\n\n    // @note Runs also when value is 0\n    // @note Avoids writing if the previous value hasn't changed\n    if (value === prevValue) return\n    prevValue = value\n\n    // @note color transitions based on total page scroll\n    const scrollComplete = root.scrollY / (root.scrollHeight - root.height)\n    const color1 = interpolateRGB(reddish, [200, 200, 200], scrollComplete)\n    const color2 = interpolateRGB(greenyellow, [0, 0, 0], scrollComplete)\n\n\n    const easedValue = easeInOutQuad(value)\n\n    if (ix === 40) {\n      console.log(value)\n    }\n\n    // @note interpolate colour based on intersection value\n    // @note do as little as possible in the rAF\n    // requestAnimationFrame(() => {\n    //   el.style.transform = `translateX(${200 * easedValue}px)`\n    //   el.style.color = `rgba(${interpolateRGB(color1, color2, easedValue).join(\",\")})`\n    // })\n\n    // @note don't do this on every frame like I am in this demo. Stagger isn't very performant and is best saved for use cases where you set a class once and want to stagger the fade in.\n    // const staggerNamespace = `p-${data.offset.top}`\n    // stagger(staggerNamespace, el, (i, len) => {\n    //   requestAnimationFrame(() => {\n    //     el.style.transform = `translateX(${100 * easedValue}px) translateY(${i * 16}px)`\n    //     el.style.color = `rgba(${interpolateRGB(color1, color2, easedValue).join(\",\")})`\n    //   })\n    // })\n\n    // const staggerNamespace = `p-${data.entry.top}`\n    // stagger(staggerNamespace, el, (i, len) => {\n      requestAnimationFrame(() => {\n        el.style.transform = `translateX(${100 * easedValue}px)`\n        el.style.color = `rgba(${interpolateRGB(color1, color2, easedValue).join(\",\")})`\n      })\n    // })\n\n    // scheduleAnimationFrame(el, (staggerIndex) => {\n    //   // setTimeout(() => {\n    //     el.style.transform = `translateX(${200 * easedValue * (staggerIndex * 10)}px)`\n    //     el.style.color = `rgba(${interpolateRGB(color1, color2, easedValue).join(\",\")})`\n    //   // }, )\n    // })\n  }\n  addScrollListener(el, onScroll)\n})\n\n\n// ---\n\nconst nav = query(\"nav\")\n\nlet lastScrollY: number = window.scrollY\nlet lastY: number = 0\nlet y: number = 0\n\naddScrollListener(nav, ({ entry, root }) => {\n  y = clamp(0, y + root.scrollY - lastScrollY, entry.height)\n\n  if (lastY !== y) {\n    requestAnimationFrame(() => {\n      nav.style.transform = `translateY(-${y}px)`\n    })\n  }\n\n  lastScrollY = root.scrollY\n  lastY = y\n})\n"],
  "mappings": "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",
  "names": []
}
