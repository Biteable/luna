{
  "version": 3,
  "sources": ["../wip/motion.ts", "index.ts"],
  "sourcesContent": ["/*\n  FLIP\n  https://www.framer.com/blog/posts/magic-motion/\n  https://github.com/julianshapiro/velocity\n  https://codepen.io/njmcode/pen/axoyD?editors=0010\n\n  Measure the first layout\n  Update the CSS and measure the last layout\n  Apply the inverted delta as a transform to make the last layout look like the first\n  Play the animation\n\n  @TODO\n  - [ ] Browser don't do a good job of transitioning from color: #specific to color: currentColor.\n        If we go down the path of transition functions for all values (colours included) and use request animation frame, this isn't a problem. Alternatively, we could trigger our transitions by writing a style tag to the dom with all values we need to transition to.\n  - [ ] There's no window.getComputedStyle($0).borderRadius in Firefox, need to get each corner individually\n  - [ ] Border radius and box shadow need to be interpolated\n  - [ ] What properties don't cause layout? We can transition all of these\n  - [ ] How do we handle elements that already have transforms on them? Does this just work?\n  - [ ] Disable existing transitions // const transitionTimingFunction =\n  - [ ] apply transition styles\n  - [ ] apply transition timing function\n  - [ ] Research the best time to do this in a frame\n\n*/\n\n\ninterface Measurement {\n  styles: any,\n  rect: {\n    top: number\n    left: number\n    width: number\n    height: number\n  }\n}\n\n\nconst borderProperties = [\n  \"borderTopLeftRadius\",\n  \"borderTopRightRadius\",\n  \"borderBottomLeftRadius\",\n  \"borderBottomRightRadius\",\n]\nconst colorProperties = [\n  \"color\",\n  \"backgroundColor\",\n]\n\nconst measure = (el: HTMLElement): Measurement => {\n  // Returning window.getComputedStyle(el) doesn't always lock the values as they were at the time we measured.\n  // Here we're just pulling out the ones we want.\n\n  const computed = window.getComputedStyle(el)\n  const styles = {\n    opacity: computed.opacity\n  }\n  borderProperties.forEach(prop => {\n    styles[prop] = computed[prop]\n  })\n  colorProperties.forEach(prop => {\n    styles[prop] = computed[prop]\n  })\n\n  const boundingRect = el.getBoundingClientRect()\n  const rect = {\n    left: boundingRect.left,\n    right: boundingRect.right,\n    top: boundingRect.top,\n    bottom: boundingRect.bottom,\n    width: boundingRect.width,\n    height: boundingRect.height,\n  }\n\n  return { styles, rect }\n}\n\n\n/**\n * calculateTransforms\n *\n * Calculates the transforms (scale, translate, etc) required to make the size, position, and a small set of other properties of an element described in `from` look like `to`.\n*/\nconst calculateTransforms = (\n  el: HTMLElement,\n  to: Measurement,\n  from: Measurement,\n  parentTo?: Measurement,\n  parentFrom?: Measurement\n) => {\n  const hasParent = !!parentTo\n  // Calculate transforms to put back in from position\n\n  const scaleX = to.rect.width / from.rect.width\n  const scaleY = to.rect.height / from.rect.height\n\n  const transforms = []\n  if (hasParent) {\n    const parentScaleX = parentTo.rect.width / parentFrom.rect.width\n    const parentScaleY = parentTo.rect.height / parentFrom.rect.height\n\n    // x/y translations must take into account the position change relative to the parent\n    const translateX = ((to.rect.left - parentTo.rect.left) / parentTo.rect.width) - ((from.rect.left - parentFrom.rect.left) / parentFrom.rect.width)\n    const translateY = ((to.rect.top - parentTo.rect.top) / parentTo.rect.height) - ((from.rect.top - parentFrom.rect.top) / parentFrom.rect.height)\n\n    transforms.push(`translateX(${translateX * 100}px)`)\n    transforms.push(`translateY(${translateY * 100}px)`)\n    transforms.push(`scaleX(${scaleX / parentScaleX})`)\n    transforms.push(`scaleY(${scaleY / parentScaleY})`)\n  } else {\n    transforms.push(`translateX(${to.rect.left - from.rect.left}px)`)\n    transforms.push(`translateY(${to.rect.top - from.rect.top}px)`)\n    transforms.push(`scaleX(${scaleX})`)\n    transforms.push(`scaleY(${scaleY})`)\n  }\n\n  return {\n    apply () {\n      if (el.classList.contains(\"circle\")) console.log(el, to.styles, from.styles)\n\n      // el.style.willChange = \"transform, opacity\"\n      el.style.transformOrigin = \"0 0\"\n      el.style.transform = transforms.join(\" \")\n      el.style.opacity = to.styles.opacity\n\n      borderProperties.forEach(prop => {\n        // @TODO still assumes single value corners and px units\n        // @TODO account for % and dual corner values\n        const val = parseFloat(to.styles[prop])\n        el.style[prop] = `${val / scaleX}px ${val / scaleY}px`;\n      })\n\n      const styles = [\"color\", \"backgroundColor\"]\n      styles.forEach((prop) => {\n        el.style[prop] = to.styles[prop]\n      })\n    }\n  }\n}\n\nexport function motion2 (el: HTMLElement, trigger: string) {\n  requestAnimationFrame(() => {\n\n    // F.L.I.P.\n    const elementsTree = makeBranches(el)\n    const elementsArr = elementsFromTree(elementsTree)\n\n    // F. (First)\n    measureFirstFrames(elementsTree)\n\n    // L. (Last)\n    // Set to end/final state and measure last frame\n    el.classList.add(trigger)\n    measureLastFrames(elementsTree)\n\n    // I. (Invert)\n    // Transform el so that it resembles the first frame\n    invert(elementsTree)\n\n    // return\n\n    // P. (Play)\n    const event = \"transitionend\"\n    const onTransitionEnd = (e: Event) => {\n      if (e.target === el) {\n        cleanup(elementsArr)\n        el.removeEventListener(event, onTransitionEnd)\n      }\n    }\n    el.addEventListener(event, onTransitionEnd)\n\n    requestAnimationFrame(() => {\n      play(elementsArr)\n    })\n  })\n\n\n  interface Branch {\n    el: HTMLElement\n    frame: {\n      first: Measurement\n      last: Measurement\n    },\n    children: Branch[]\n  }\n\n\n  function play (els: HTMLElement[]) {\n    // const transition = \"all 3s ease-out\"\n    const transition = \"all 0.6s cubic-bezier(.17,.05,.42,1)\"\n\n    els.forEach(el => {\n      el.style.transition = transition\n      el.style.transformOrigin = \"\"\n      el.style.transform = \"\"\n      el.style.opacity = \"\"\n      borderProperties.forEach(prop => {\n        el.style[prop] = \"\";\n      })\n      el.style.willChange = \"\"\n\n      const styles = [\"color\", \"backgroundColor\"]\n      styles.forEach((prop) => {\n        el.style[prop] = \"\"\n      })\n    })\n  }\n\n\n  function cleanup (els: HTMLElement[]) {\n    els.forEach(el => {\n      el.style.transition = \"\"\n    })\n  }\n\n\n  function elementsFromTree (branch: Branch) {\n    const els = []\n    const pushBranchEl = (branch: Branch) => {\n      els.push(branch.el)\n      branch.children.forEach(pushBranchEl)\n    }\n    pushBranchEl(branch)\n    return els\n  }\n\n\n  function invert (branch: Branch, parentBranch?: Branch) {\n    const transforms = parentBranch\n      ? calculateTransforms(branch.el, branch.frame.first, branch.frame.last, parentBranch.frame.first, parentBranch.frame.last)\n      : calculateTransforms(branch.el, branch.frame.first, branch.frame.last)\n\n    transforms.apply()\n\n    branch.children.forEach(child => { invert(child, branch) })\n  }\n\n\n  function measureFirstFrames (branch: Branch) {\n    branch.frame.first = measure(branch.el)\n    branch.children.forEach(measureFirstFrames)\n  }\n\n\n  function measureLastFrames (branch: Branch) {\n    branch.frame.last = measure(branch.el)\n    branch.children.forEach(measureLastFrames)\n  }\n\n\n  function makeBranches (el: HTMLElement): Branch {\n    return {\n      el: el,\n      frame: {\n        first: null,\n        last: null\n      },\n      children: (Array.from(el.children) as HTMLElement[]).map(makeBranches)\n    }\n  }\n}\n\n\nexport const motion = (el: HTMLElement, className: string) => {\n  const childEls = Array.from(el.children) as HTMLElement[]\n\n  // requestAnimationFrame(() => {})\n  let first\n  let childsFirst\n  let last\n  let childsLast\n\n  requestAnimationFrame(() => {\n    // FLIP\n\n    // F. (First)\n    // Measure first frame\n    first = measure(el)\n    childsFirst = childEls.map(measure)\n\n    // L. (Last)\n    // Set to end/final state and measure last frame\n    el.classList.add(className)\n    last = measure(el)\n    childsLast = childEls.map(measure)\n\n    // I. (Invert)\n    // Transform el so that it resembeles the first frame\n    applyTransforms()\n\n    // P. (Play)\n    unapply(el)\n    childEls.forEach(el => unapply(el))\n\n    // Testing: add transition styles\n    // const transition = \"all 1s ease-out\"\n    const transition = \"all 0.7s cubic-bezier(.17,.05,.42,1)\"\n    el.style.transition = transition\n    childEls.forEach(el => el.style.transition = transition)\n  })\n\n\n  function applyTransforms () {\n    const parentTransforms = calculateTransforms(el, first, last)\n    const childrenTransforms = childEls.map((el, ix) => {\n      return calculateTransforms(el, childsFirst[ix], childsLast[ix], first, last)\n    })\n\n    parentTransforms.apply()\n    childrenTransforms.forEach(x => { x.apply() })\n  }\n\n  function unapply (el: HTMLElement) {\n    el.style.transformOrigin = \"\"\n    el.style.transform = \"\"\n    el.style.borderRadius = \"\";\n  }\n}\n\n", "import { query, queryAll, find, findAll, addClass, removeClass, css } from \"../dom\"\nimport { motion, motion2 } from \"../wip/motion\"\n\n// const el = query(\"#one\")\n// const els = queryAll(\".many\")\n\n// // Add styles to a single el.\n// css(el, { top: \"100px\", left: \"\" })\n\n// // Many\n// els\n//   .map(x => css(x, { left: \"\" }))      // Remove inline css from all\n//   .map(x => removeClass(x, \"active\"))   // Remove active class from all\n// // .filter(x => x === el)                // Filter list to just #one\n// // .map(x => addClass(x, \"active\"))      // Add active class to #one\n// // .map(x => css(x, { left: \"100px\" }))  // Add styles to #one\n\n// // Single\n// addClass(el, \"active\")\n// css(el, { left: \"100px\" })\n\n\nconst runBtn = document.querySelector(\"[data-run]\") as HTMLButtonElement\nconst card = document.querySelector(\".befaux .card\") as HTMLElement\n\nconst motionBtns = Array.from(document.querySelectorAll(\"[data-motion]\")) as HTMLButtonElement[]\nconst testEls = Array.from(document.querySelectorAll(\".befaux > div\")) as HTMLElement[]\n\nmotionBtns.forEach((el, ix) => {\n  el.addEventListener(\"click\", () => {\n    console.log(testEls[ix], el)\n    motion2(testEls[ix], \"end\")\n  })\n})\n\nrunBtn.addEventListener(\"click\", () => {\n  motion(card, \"end\")\n})\n"],
  "mappings": "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",
  "names": []
}
