{
  "version": 3,
  "sources": ["../dom/exists.ts", "../dom/query.ts", "../util/debounce.ts", "../veneer/component.ts", "component.ts"],
  "sourcesContent": ["export const exists = (node: HTMLElement) => {\n  return document.documentElement.contains(node)\n}", "export const find = (scope: HTMLElement | Document, selector: string) => scope.querySelector(selector) as HTMLElement\n\nexport const findAll = (scope: HTMLElement | Document, selector: string) => [].slice.call(scope.querySelectorAll(selector)) as HTMLElement[]\n\nexport const query = (selector: string) => find(document, selector)\n\nexport const queryAll = (selector: string) => findAll(document, selector)\n", "export const debounce = (func: any, wait: number, immediate: boolean = false) => {\n  let timeout: number\n  return function () {\n    var context = this, args = arguments\n    window.clearTimeout(timeout)\n    timeout = window.setTimeout(function () {\n      timeout = null\n      if (!immediate) func.apply(context, args)\n    }, wait)\n    if (immediate && !timeout) func.apply(context, args)\n  }\n}\n", "/*\n\n`unmount` is a cleanup opportunity where you can remove any event listeners that don't get automatically removed (for example window scroll/resize listeners). You should assume that the element is no longer in the DOM. It's not the place to run an animation to fade out an element, for example.\n\n\n// Simple usage\n\ncomponent(\".ComponentWithButton\", (el) => {\n  const button = el.querySelector(\"button\")\n  button.addEventListener(\"click\", () => {\n    console.log(\"You clicked a button inside me!\", el)\n  })\n})\n\n\n// scroll listener usage\n\nimport { addScrollListener, removeScrollListener } from ..\ncomponent(\".SomethingOnScroll\", (el, { unmount }) => {\n  function onScroll () {\n    // Do something in response to scroll events\n    requestAnimationFrame(() => {\n      // Update DOM\n    })\n  }\n\n  addScrollListener(el, onScroll)\n\n  unmount(() => {\n    removeScrollListener(el, onScroll)\n  })\n})\n\n\n// Responding to entering the viewport usage\n\ncomponent(\".AnimateWhenFirstVisible\", (el, on) => {\n  // @todo handle setting initial visibility status to, say, opacity 0 then calling an intersection function once in a new paint frame\n})\n\n*/\n\n\nimport { debounce } from \"../util/debounce\"\nimport { exists } from \"../dom\"\n\n\n// let initiated: boolean = false\nlet entries: Entry[] = []\nlet domObserver: MutationObserver = undefined\n\n// Register of elements with public methods\nlet register: Map<HTMLElement, any> = new Map()\n\ntype MountFn = (el: HTMLElement, actions: Actions) => void\n\ninterface EntryInstance {\n  el: HTMLElement\n  onunmount: () => void\n}\n\ninterface Entry {\n  selector: string\n  onmount: MountFn\n  liveList: HTMLCollection,\n  instances: EntryInstance[]\n}\n\ninterface Actions {\n  unmount: (onUnmount: () => void) => void\n  setMethods: (obj: any) => void\n  getMethods: (el: HTMLElement) => any\n}\n\n\nexport function component(selector: string, onmount: MountFn) {\n  return {\n    observe() {\n      registerComponent(selector, onmount)\n    },\n    disconnect() {\n      unregisterComponent(selector)\n    },\n  }\n}\n\n\nexport function update() {\n  entries = entries.map(entry => {\n    const mountedEls: HTMLElement[] = []\n\n    // Handle elements removed from the DOM\n    entry.instances = entry.instances.reduce((instances, instance) => {\n      const { el, onunmount } = instance\n      // Check that element exists in the document\n      if (exists(el)) {\n        mountedEls.push(el)\n        instances.push(instance)\n      } else {\n        onunmount()\n      }\n      return instances\n    }, [])\n\n      // Handle elements newly added to the DOM\n      ; ([].slice.call(entry.liveList) as HTMLElement[]).forEach(el => {\n        if (!mountedEls.includes(el)) {\n          // Mount new found component elements\n          entry.instances.push(mountInstance(el, entry.onmount))\n        }\n      })\n\n    return entry\n  })\n}\n\n\nfunction registerComponent(selector: string, onmount: MountFn) {\n  if (!selector.startsWith(\".\") || selector.includes(\" \")) {\n    console.error(`Class selectors only please; eg \".Component\"`)\n    return\n  }\n\n  // Skip of already registered\n  if (entries.some((entry) => entry.selector === selector)) return\n\n  // Find matching elements in the DOM\n  const liveList = document.getElementsByClassName(selector.slice(1))\n  const els = [].slice.call(liveList)\n\n  // Iterate elements and mount each as a component instance\n  const instances = els.map((el: HTMLElement) => mountInstance(el, onmount))\n\n  // Push to entries\n  entries.push({ selector, onmount, liveList, instances })\n\n  //\n  if (!domObserver) {\n    const onDomMutation = debounce(update, 250)\n    domObserver = new MutationObserver(onDomMutation)\n    domObserver.observe(document.documentElement, { attributes: false, childList: true, subtree: true })\n  }\n}\n\n\nfunction mountInstance(el: HTMLElement, onmount: MountFn) {\n  const instance: EntryInstance = {\n    el: el,\n    onunmount: () => { }\n  }\n\n  const actions: Actions = {\n    unmount: (cb) => {\n      instance.onunmount = cb // Mutate instance onunmount callback\n    },\n    setMethods: (obj) => {\n      register.set(el, obj)\n    },\n    getMethods: (el) => new Promise((resolve, reject) => {\n      setTimeout(() => {\n        const methods = register.get(el)\n        if (methods) resolve(methods)\n        else reject()\n      }, 0); // Push to end of stack to ensure all components are init'ed\n    })\n  }\n\n  onmount(el, actions) // Call mount function on element\n\n  return instance\n}\n\n\nfunction unregisterComponent(selector: string) {\n  const entry = entries.find((entry) => entry.selector === selector)\n  if (!entry) return\n  const index = entries.indexOf(entry)\n  entries[index].instances.forEach(({ el }) => {\n    register.delete(el)\n  })\n  entries.splice(index, 1)\n}\n", "import { find, findAll } from \"../dom\"\nimport { component } from \"../veneer/component\"\n\n\nconst Apple = component(\".Apple\", (el, { setMethods }) => {\n  console.log(\"Init \uD83C\uDF4F\")\n  const state = {\n    clicks: 0\n  }\n\n  const button = find(el, \"button\")\n  const count = find(el, \"small\")\n  const click = () => {\n    state.clicks++\n    count.innerText = state.clicks.toString()\n    console.log(`\uD83C\uDF4F ${state.clicks} clicks`)\n  }\n  button.addEventListener(\"click\", click)\n\n  setMethods({ click })\n})\n\n\nconst Banana = component(\".Banana\", (el, { getMethods }) => {\n  // console.log(\"Init \uD83C\uDF4C\", el)\n  const button = find(el, \"button\")\n\n  const SaladBowl = el.closest(\".SaladBowl\") as HTMLElement\n  if (SaladBowl) {\n    button.addEventListener(\"click\", () => getMethods(SaladBowl).then(salad => salad.logFruit()))\n  } else {\n    console.log(\"Not in a salad bowl\")\n  }\n})\n\n\nconst SaladBowl = component(\".SaladBowl\", (el, { getMethods, setMethods }) => {\n  const apples = findAll(el, \".Apple\") // There's no magic here. If you mess with DOM after this query (eg delete the apple nodes) you'll still have a reference to these Apples\n  const buttons = findAll(el, \"[data-click-apple]\")\n  const disconnect = find(el, \"[data-disconnect-apples]\")\n\n  // Click last apple on mount/init\n  getMethods(apples[apples.length - 1]).then(methods => methods.click())\n\n  buttons.forEach((btn, ix) => {\n    btn.addEventListener(\"click\", () => {\n      getMethods(apples[ix]).then(methods => methods.click())\n    })\n  })\n\n  setMethods({\n    logFruit: () => console.log(findAll(el, \".Apple, .Banana\")),\n  })\n\n  disconnect.addEventListener(\"click\", Apple.disconnect) // Disconnected Apples can still change their own state based on their own eventListeners\n})\n\n// Initiate\nSaladBowl.observe()\nApple.observe()\nBanana.observe()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// const Banana = component(\".Banana\", (el) => {\n//   console.log(\"Init \uD83C\uDF4C\", el)\n\n//   requestAnimationFrame(() => {\n//     el.style.opacity = \"0\"\n//   })\n\n//   let visible: boolean\n\n//   addScrollListener(el, (data) => {\n//     if (intersectionRatio(data) > 0.5) {\n\n//       // This prevents this running twice. Which is indicative of removeScrollListener not acting fast enough\n//       if (visible) return\n//       visible = true\n\n//       removeScrollListener(el) // Remove all scroll listeners on this element\n\n//       stagger(\"Banana\", el, (ix) => {\n//         console.log(\"intersecting\", el, ix)\n\n//         setTimeout(() => {\n//           requestAnimationFrame(() => {\n//             style(el, {\n//               opacity: \"\",\n//               transition: \"all 0.5s ease-out\",\n//             })\n//           })\n//         }, 20 + 100 * ix)\n//       })\n//     }\n//   })\n// })\n"],
  "mappings": "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",
  "names": []
}
